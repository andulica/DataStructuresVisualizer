@using DataStructuresVisualizer.DataStructures.BinarySearchTree;
@inject IJSRuntime JSRuntime

<h3>Binary Search Tree</h3>

<!-- Input for operations -->
<div>
    <input @bind="inputValue" type="number" placeholder="Enter value" />
    <button @onclick="() => InsertValue()">Insert</button>
    <button @onclick="() => SearchValue()">Search</button>
    <button @onclick="() => RemoveValue()">Remove</button>
    <button @onclick="() => CreateTree()">Create</button>
</div>

<!-- Traversal operations -->
<div>
    @* <button @onclick="() => InOrderTraversal()">In-Order</button> *@
@*     <button @onclick="() => PreOrderTraversal()">Pre-Order</button>
    <button @onclick="() => PostOrderTraversal()">Post-Order</button> *@
</div>

<!-- Display area for the BST -->
<div id="bst-display">
    @* Render the tree here *@
</div>

<!-- Messages -->
<div>@message</div>


@code {
    private BinarySearchTree<int> bst = new BinarySearchTree<int>(5);
    private int inputValue;
    private string message;
    private Random rand = new Random();

    private void CreateTree()
    {
        bst = new BinarySearchTree<int>(5);
        UpdateDisplay(bst).ContinueWith(_ => { }); // Handle async call without await
    }

    private void InsertValue()
    {
        if (!this.bst.Insert(inputValue))
        {
            message = "Value inserted must be less than 100 and greater than 0.";
        }
        else
        {
            UpdateDisplay(this.bst).ContinueWith(_ => { }); // Handle async call without await
        }
    }

    private async Task SearchValue()
    {
        await JSRuntime.InvokeVoidAsync("searchValueInBST", inputValue);
        // await UpdateDisplay().ContinueWith(_ => { }); Handle async call without await
    }

    private void RemoveValue()
    {
        bst.Remove(inputValue);
        UpdateDisplay(this.bst).ContinueWith(_ => { }); // Handle async call without await
    }

    // private void InOrderTraversal()
    // {
    //     // Implement traversal logic and update display
    // }

    private async Task UpdateDisplay(BinarySearchTree<int> bst)
    {
        var bstData = ConvertBSTToD3Format(bst.Root);
        await JSRuntime.InvokeVoidAsync("drawBST", bstData);
    }

    private object ConvertBSTToD3Format(TreeNode<int> node)
    {
        if (node == null)
        {
            return null; // Return null for nodes that don't exist
        }

        // Convert left and right children recursively.
        // If a child is null, it remains null in the JSON, making it easier to understand the tree structure.
        var leftChild = node.Left != null ? ConvertBSTToD3Format(node.Left) : null;
        var rightChild = node.Right != null ? ConvertBSTToD3Format(node.Right) : null;

        // Construct the result object. Include 'left' and 'right' only if they exist.
        var result = new
        {
            id = node.Id.ToString(), // Convert Guid to string for JavaScript compatibility
            name = node.Data.ToString(),
            left = leftChild, // Directly assign the left child (can be null)
            right = rightChild, // Directly assign the right child (can be null)
            visited = node.IsVisited
        };

        return result;
    }



    // Similar methods for PreOrder and PostOrder
}
