@using DataStructuresVisualizer.DataStructures.Queue;
@using DataStructuresVisualizer.DataStructures.SinglyLinkedListFile;
@using DataStructuresVisualizer.DataStructures;

@inject IJSRuntime JSRuntime
@inject CancellationService CancellationService


<head>
    <link rel="stylesheet" href="/css/styles.css" />
</head>

<div id="linked-list" class="container">
    <h3>Queue</h3>

    <div class="operation-selection">
        <select @onchange="OnActionChanged">
            <option value="" disabled selected>Select an Operation</option> <!-- Initial message -->
            <option value="Peek">Peek</option>
            <option value="Enqueue">Enqueue</option>
            <option value="Dequeue">Dequeue</option>
            <option value="Create">Create</option>
        </select>
        @switch (selectedAction)
        {
            case "Peek":
                <div class="insertion-fields">
                    <button class="custom-button" @onclick="PeekFront" disabled="@isOperationInProgress">Peek Front</button>
                    <button class="custom-button" @onclick="PeekBack" disabled="@isOperationInProgress">Peek Back</button>

                </div>
                break;
            case "Enqueue":
                <div class="insertion-fields">
                    <label for="inputValue">Input Value</label>
                    <input type="number" id="inputValue" @bind="inputValue" placeholder="Enter Value" />

                    <button class="custom-button" @onclick="Enqueue" disabled="@isOperationInProgress">Enqueue</button>
                </div>
                break;
            case "Dequeue":
                <div class="insertion-fields">
                    <label for="inputValue">Kx (Dequeue)</label>
                    <input type="number" id="inputValue" @bind="inputValue" placeholder="Enter Value" />

                    <button class="custom-button" @onclick="Dequeue" disabled="@isOperationInProgress">Dequeue</button>
                </div>
                break;
            case "Create":
                <div class="insertion-fields">
                    <label for="inputValue">Input Value</label>
                    <input type="number" id="inputValue" @bind="inputValue" placeholder="Enter Value" />

                    <button class="custom-button" @onclick="CreateQueue" disabled="@isOperationInProgress">Create</button>
                </div>
                break;
            default:
                break;
        }
    </div>

    <div id="sll-display">
        @* Render the queue here *@
    </div>

    <CodeDisplay CodeLines="@currentCode" />


    @if (!string.IsNullOrEmpty(messageOutput))
    {
        <div class="notification-container">
            <span class="notification-message">@messageOutput</span>
            <button class="notification-close" @onclick="ClearMessage">✖</button>
        </div>
    }
</div>

@code {
    private QueueStructure<int> queue = new QueueStructure<int>();
    private int inputValue;
    private string messageOutput;
    private bool isOperationInProgress = false;
    Random rand = new Random();
    private string _selectedAction = "create";
    private string subSelectedAction = "";
    private IEnumerable<string> currentCode = Enumerable.Empty<string>();
    VisualizationTiming timing = VisualizationTiming.Default;


    public string selectedAction
    {
        get => _selectedAction;
        set
        {
            if (_selectedAction != value)
            {
                _selectedAction = value;
                currentCode = GetCodeByOperation(value);
                StateHasChanged();
            }
        }
    }

    protected override void OnInitialized()
    {
        queue.Add(rand.Next(1, 30));
        queue.Add(rand.Next(1, 30));
        queue.Add(rand.Next(1, 30));

        SubscribingNewList();
    }

    public void Dispose()
    {
        UnsubscribingOldList();
    }

    private void OnActionChanged(ChangeEventArgs e)
    {
        selectedAction = e.Value.ToString();
        InitializeNewOperation(); // Cancel the ongoing operation when a new action is selected
    }

    private CancellationToken InitializeNewOperation()
    {
        CancellationService.ResetCancellationTokenSource();
        return CancellationService.GetToken();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            var queueData = ConvertQueueToJavaScriptFormat(queue);
            await JSRuntime.InvokeVoidAsync("drawLinkedList", queueData);
        }
    }

    private IEnumerable<string> GetCodeByOperation(string operation)
    {
        Dictionary<string, IEnumerable<string>> codeSnippets = new Dictionary<string, IEnumerable<string>>
            {
                ["peek front"] = new List<string>
                {
                    "if empty, return NOT_FOUND",
                    "return head.item"
                },
                ["peek back"] = new List<string>
                {
                    "if empty, return NOT_FOUND",
                    "return tail.item"
                },
                ["Enqueue"] = new List<string>
                {
                    "Vertex vtx = new Vertex(v)",
                    "tail.next = vtx",
                    "tail = vtx"
                },
                ["Dequeue"] = new List<string>
                {
                    "for (i = 0; i < K; ++i)",
                    "tmp = head",
                    "head = head.next",
                    "delete tmp"
                }
            };

        if (codeSnippets.TryGetValue(operation, out var code))
        {
            return code;
        }
        return new List<string> { "Select an operation to view the code." };
    }

    private object ConvertNodeToJavaScriptFormat(SinglyLinkedListNode<int> node)
    {
        return new
        {
            value = node._data,
            next = node.Next != null ? node.Next.Id : (Guid?)null,
            id = node.Id
        };
    }

    private List<object> ConvertQueueToJavaScriptFormat(QueueStructure<int> queue)
    {
        var nodes = new List<object>();
        var currentNode = queue.Head;
        while (currentNode != null)
        {
            nodes.Add(new
            {
                value = currentNode._data,
                next = currentNode.Next != null ? currentNode.Next.Id : (Guid?)null,
                id = currentNode.Id
            });
            currentNode = currentNode.Next;
        }
        return nodes;
    }

    private async Task CreateQueue()
    {
        if (isOperationInProgress) return;

        if (inputValue > queue.maxCapacity)
        {
            messageOutput = $"The queue can have a maximum number of {queue.maxCapacity} nodes. Please enter a smaller value.";
            return;
        }

        queue = new QueueStructure<int>();

        for (int i = 0; i < inputValue; i++)
        {
            queue.Add(rand.Next(1, 30));
        }
        SubscribingNewList();
        await UpdateDisplay(queue);
    }

    private async Task Dequeue()
    {
        var token = InitializeNewOperation(); // Ensure ongoing operation is cancelled before starting a new one

        if (isOperationInProgress) return;

        if (inputValue > queue.Count)
        {
            messageOutput = $"The queue has {queue.Count} nodes. Please enter a smaller value to dequeue.";
            return;
        }

        isOperationInProgress = true;
        StateHasChanged();
        int remainingNumberOfNodesToBeRemoved = inputValue;
        bool lastNodeToBeRemovedBoolFlag = false;
        try
        {
            for (int i = 1; i <= inputValue; i++)
            {
                if (i == inputValue)
                {
                    lastNodeToBeRemovedBoolFlag = true;
                }
                var nodeToRemove = queue.Head;
                var nodeToBeRemovedFromSVG = ConvertNodeToJavaScriptFormat(nodeToRemove);
                var removeTask = queue.Dequeue(nodeToRemove, token);
                remainingNumberOfNodesToBeRemoved -= i;

                var jsTask = JSRuntime.InvokeVoidAsync("removeValueInSll", nodeToBeRemovedFromSVG, timing, false, lastNodeToBeRemovedBoolFlag).AsTask();
                await Task.WhenAll(removeTask, jsTask); // Run both tasks concurrently
                await Task.Delay(timing.HighlightDelay, token);
            }
        }
        catch (OperationCanceledException)
        {
            messageOutput = $"The visual was cancelled. A number of {inputValue} where dequeued.";
            queue.DequeueInstant(remainingNumberOfNodesToBeRemoved);

            var queueData = ConvertQueueToJavaScriptFormat(queue);

            await JSRuntime.InvokeVoidAsync("SllCancelVisuals");
            await JSRuntime.InvokeVoidAsync("drawLinkedList", queueData, false);
        }
        finally
        {
            isOperationInProgress = false;
            var resetCodeLineHighlight = JSRuntime.InvokeVoidAsync("resetCodeLineHighlight").AsTask();
            StateHasChanged();
        }
    }

    private async Task Enqueue()
    {
        if (isOperationInProgress) return;

        if (queue.Count == queue.maxCapacity)
        {
            messageOutput = $"The queue has reached maximum number of nodes. Please dequeue a value or create a smaller queue.";
            return;
        }

        isOperationInProgress = true;
        StateHasChanged();

        try
        {
            var nodeToEnqueue = new SinglyLinkedListNode<int>(inputValue);
            var nodeToBeEnqueuedOnSVG = ConvertNodeToJavaScriptFormat(nodeToEnqueue);
            var queueTask = queue.Enqueue(nodeToEnqueue);
            var JSTask =  JSRuntime.InvokeVoidAsync("insertTailInSll", nodeToBeEnqueuedOnSVG, timing).AsTask();

            await Task.WhenAll(queueTask, JSTask);
        }
        finally
        {
            var resetCodeLineHighlight = JSRuntime.InvokeVoidAsync("resetCodeLineHighlight").AsTask();

            isOperationInProgress = false;
            StateHasChanged();
        }
    }

    private async Task PeekBack()
    {
        var token = InitializeNewOperation();

        if (isOperationInProgress)
        {
            return;
        }

        isOperationInProgress = true;

        subSelectedAction = "peek back";
        currentCode = GetCodeByOperation("peek back");

        try
        {
            var peekFront = queue.PeekBack(token);
            var jsTask = JSRuntime.InvokeVoidAsync("highlightTail").AsTask();
            await Task.WhenAll(peekFront, jsTask);
            await Task.Delay(Constants.operationCancellationTime);
            var resetCodeLineHighlight = JSRuntime.InvokeVoidAsync("resetCodeLineHighlight").AsTask();
            var resetNodeColour = JSRuntime.InvokeVoidAsync("resetNodeColoursFromCS").AsTask();
            await Task.WhenAll(resetCodeLineHighlight, resetNodeColour);
        } catch (OperationCanceledException)
        {
        }

        isOperationInProgress = false;
    }

    private async Task PeekFront()
    {
        if (isOperationInProgress)
        {
            return;
        }

        isOperationInProgress = true;

        subSelectedAction = "peek front";
        currentCode = GetCodeByOperation("peek front");

        var peekFront = queue.PeekFront();
        var jsTask = JSRuntime.InvokeVoidAsync("highlightHead").AsTask();
        await Task.WhenAll(peekFront, jsTask);
        await Task.Delay(Constants.operationCancellationTime);
        var resetCodeLineHighlight = JSRuntime.InvokeVoidAsync("resetCodeLineHighlight").AsTask();
        var resetNodeColour = JSRuntime.InvokeVoidAsync("resetNodeColoursFromCS").AsTask();
        await Task.WhenAll(resetCodeLineHighlight, resetNodeColour);

        isOperationInProgress = false;
    }

    private async Task HandleHighlightRequest(Enum step)
    {
        await JSRuntime.InvokeVoidAsync("highlightLine", step);
        await Task.Delay(timing.HighlightDelay);
    }

    private void SubscribingNewList()
    {
        queue.HighlightRequested += HandleHighlightRequest; // Subscribe to highlight events
    }

    private void UnsubscribingOldList()
    {
        queue.HighlightRequested -= HandleHighlightRequest;
    }

    private async Task UpdateDisplay(SinglyLinkedList<int> list)
    {
        var queueData = ConvertQueueToJavaScriptFormat(queue);
        await JSRuntime.InvokeVoidAsync("drawLinkedList", queueData);
    }

    private void ClearMessage()
    {
        messageOutput = "";
    }
}